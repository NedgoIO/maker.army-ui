'use strict';

/* eslint global-require: 0, consistent-return: 0 */

var Filter = require('broccoli-persistent-filter');
var CLIEngine = require('eslint').CLIEngine;
var md5Hex = require('md5-hex');
var stringify = require('json-stable-stringify');
var path = require('path');
var escapeStringRegexp = require('escape-string-regexp');
var BUILD_DIR_REGEXP = new RegExp('(' + escapeStringRegexp(path.sep) + ')?build(' + escapeStringRegexp(path.sep) + ')?$');
var IGNORED_FILE_MESSAGE_REGEXP = /(?:File ignored by default\.)|(?:File ignored because of a matching ignore pattern\.)/;

/**
 * Calculates the severity of a eslint.linter.verify result
 * @param {Array} resultMessages ESLint's verify() result array
 *    @see: http://eslint.org/docs/developer-guide/nodejs-api#linter
 *
 * @returns {Number} accumulatedSeverity The total severity from of the list of results
 *    0 indicates all-clear
 *    1 indicates a warning-level result
 *    > 1 indicates an error-level result
 */
function getResultSeverity() {
  var resultMessages = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

  return resultMessages.reduce(function (accumulatedSeverity, message) {
    var severity = message.severity || 0;

    if (message.fatal || severity === 2) {
      return accumulatedSeverity + 2;
    }

    return accumulatedSeverity + severity;
  }, 0);
}

/**
 * Ignores messages that are about ignored files as they are intended
 * but we are processing a file at a time
 *
 * @param {Array} errors result errors
 * @returns {Array} filtered errors
 */
function filterIgnoredFileMessages(errors) {
  return errors.filter(function (error) {
    return !IGNORED_FILE_MESSAGE_REGEXP.test(error.message);
  });
}

/**
 * Filters all ignored file messages from result object
 * @param {Object} result result errors
 * @returns {Object} filtered results
 */
function filterAllIgnoredFileMessages(result) {
  var resultOutput = result;

  resultOutput.results.forEach(function (resultItem) {
    resultItem.messages = filterIgnoredFileMessages(resultItem.messages);
  });

  return resultOutput;
}

function isString(x) {
  return toString.call(x) === '[object String]';
}

function resolveInputDirectory(inputNode) {
  if (typeof inputNode === 'string') {
    return inputNode;
  }

  // eslint-disable-next-line no-underscore-dangle
  var nodeInfo = inputNode.__broccoliGetInfo__();

  if (nodeInfo.nodeType === 'source') {
    return nodeInfo.sourceDirectory;
  }

  if (nodeInfo.inputNodes.length > 1) {
    // eslint-disable-next-line max-len
    throw new Error('EslintValidationFilter can only handle one:* broccoli nodes, but part of the given input pipeline is a many:* node. (broccoli-merge-trees is an example of a many:* node) Please perform many:* operations after linting.');
  }

  return resolveInputDirectory(nodeInfo.inputNodes[0]);
}

/**
 * Uses the content of each file in a given node and runs eslint validation on it.
 * @param {Object} inputNode Node from broccoli.makeTree
 * @param {{config: String, rulesdir: String, format: String}} options Filter options
 * @returns {EslintValidationFilter} Filter obconfig @constructor
 */
function EslintValidationFilter(inputNode) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (!(this instanceof EslintValidationFilter)) {
    return new EslintValidationFilter(inputNode, options);
  }

  this.internalOptions = options || {};
  var eslintOptions = options.options || {};

  // default ignore:true option
  if (typeof eslintOptions.ignore === 'undefined') {
    eslintOptions.ignore = true;
  }

  // default is to persist filter output
  if (typeof this.internalOptions.persist === 'undefined') {
    this.internalOptions.persist = true;
  }

  // call base class constructor
  Filter.call(this, inputNode, this.internalOptions);

  // set formatter
  if (typeof this.internalOptions.format === 'function') {
    this.formatter = this.internalOptions.format;
  } else {
    // eslint-disable-next-line global-require
    this.formatter = require(this.internalOptions.format || 'eslint/lib/formatters/stylish');
  }

  this.console = options.console || console;

  this.cli = new CLIEngine(eslintOptions);

  this.eslintrc = resolveInputDirectory(inputNode);

  if (isString(this.internalOptions.testGenerator)) {
    var testGenerators = require('./test-generators');

    this.testGenerator = testGenerators[this.internalOptions.testGenerator];
    if (!this.testGenerator) {
      throw new Error('Could not find \'' + this.internalOptions.testGenerator + '\' test generator.');
    }
  } else {
    this.testGenerator = this.internalOptions.testGenerator;
  }

  if (this.testGenerator) {
    this.targetExtension = 'lint-test.js';
  }
}

module.exports = EslintValidationFilter;
EslintValidationFilter.prototype = Object.create(Filter.prototype);
EslintValidationFilter.prototype.constructor = EslintValidationFilter;
EslintValidationFilter.prototype.extensions = ['js'];
EslintValidationFilter.prototype.targetExtension = 'js';

EslintValidationFilter.prototype.baseDir = function baseDir() {
  return __dirname.replace(BUILD_DIR_REGEXP, '');
};

EslintValidationFilter.prototype.cacheKeyProcessString = function cacheKeyProcessString(content, relativePath) {
  function functionStringifier(key, value) {
    if (typeof value === 'function') {
      return value.toString();
    }
    return value;
  }

  var filePath = path.join(this.eslintrc, relativePath);
  var isIgnoredFile = this.cli.isPathIgnored(filePath);

  return md5Hex([content, relativePath, isIgnoredFile.toString(), stringify(this.internalOptions, { replacer: functionStringifier }), stringify(this.cli.getConfigForFile(filePath))]);
};

EslintValidationFilter.prototype.processString = function processString(content, relativePath) {
  // verify file content
  var configPath = path.join(this.eslintrc, relativePath);
  var report = this.cli.executeOnText(content, configPath);
  var filteredReport = filterAllIgnoredFileMessages(report);

  var toCache = { report: report, output: content };

  if (this.testGenerator && Array.isArray(filteredReport.results)) {
    var result = filteredReport.results[0] || {};
    var messages = result.messages || [];

    toCache.output = this.testGenerator(relativePath, messages, result);
  }

  return toCache;
};

/**
 * Post-process the filtered output, calculating the result severity from the report
 * if the option to `throwOnError` has been set
 *
 * @param {Object} results A results object returned from `processString`
 * @param {Object} results.report The report returned from this.cli.executeOnText()
 * @param {string} results.output The original file content passed to `processString` -- or the
 *      result of executing the a provided `testGenerator` function on the `report`
 *
 * @returns {Object} An object with an `.output` property, which will be
 *    used as the emitted file contents
 */
EslintValidationFilter.prototype.postProcess = function postProcess(results /* , relativePath */) {
  var report = results.report,
      output = results.output;

  // if verification has result

  if (report.results.length && report.results[0].messages.length) {

    // log formatter output
    this.console.log(this.formatter(report.results));

    var throwOnWarn = !!this.internalOptions.throwOnWarn;
    var throwOnError = !!this.internalOptions.throwOnError;

    if (throwOnWarn || throwOnError) {
      var resultSeverity = getResultSeverity(report.results[0].messages);

      if (resultSeverity === 1 && throwOnWarn) {
        throw new Error('rules violation with `warn` severity level');
      }

      if (resultSeverity >= 2 && (throwOnWarn || throwOnError)) {
        throw new Error('rules violation with `error` severity level');
      }
    }
  }

  return {
    output: output
  };
};